<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Bet</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <link rel="icon" type="image/png" href="../../img/logoPB.png">
    <!-- SWEETALERT2 -->
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <!-- GSAP for Pixel Transitions -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <!-- QR CODE LIBC (Generation) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <!-- QR CODE SCANNER (html5-qrcode) -->
    <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>

    <style>
        /* --- VARIABLES & RESET --- */
        :root {
            --bg-color: #0d0d12;
            --panel-bg: #1a1a24;
            --text-primary: #e0e0e0;
            --text-dim: #6b6b80;

            --accent-cyan: #4ff0ff;
            --accent-red: #ff4f4f;
            --accent-amber: #ffb84f;
            --accent-green: #4fff86;
            --accent-white: #ffffff;
            --accent-black: #111111;

            --font-pixel: 'VT323', monospace;
        }

        /* --- CUSTOM SCROLLBAR --- */
        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-color);
            border-left: 1px solid var(--panel-bg);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--panel-bg);
            border: 1px solid var(--accent-cyan);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-primary);
            font-family: var(--font-pixel);
            font-size: 20px;
            /* height: 100vh; Removed to allow scroll */
            min-height: 100vh;
            overflow-y: auto;
            /* Enable vertical scroll */
            display: flex;
            flex-direction: column;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* --- CRT OVERLAY --- */
        .crt-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .scanlines {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%);
            background-size: 100% 4px;
            animation: scanmove 0.3s linear infinite;
        }

        .vignette {
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(0, 0, 0, 0) 60%, rgba(0, 0, 0, 0.6) 100%);
        }

        @keyframes scanmove {
            0% {
                background-position: 0 0;
            }

            100% {
                background-position: 0 4px;
            }
        }

        /* --- UX ENHANCEMENTS --- */
        .step-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            background: var(--accent-amber);
            color: black;
            font-weight: bold;
            font-size: 1.5rem;
            border-radius: 4px;
            margin-right: 12px;
            box-shadow: 3px 3px 0 rgba(0, 0, 0, 0.5), 0 0 10px rgba(255, 184, 79, 0.3);
            image-rendering: pixelated;
            transform-style: preserve-3d;
            animation: badgefloat 5s infinite ease-in-out;
        }

        @keyframes badgefloat {

            0%,
            100% {
                transform: rotate3d(1, 1, 0, 0deg) translateY(0);
            }

            50% {
                transform: rotate3d(1, 1, 0, 10deg) translateY(-2px);
            }
        }

        /* Buttons classes handled later in the main CSS section */

        .wifi-notice {
            background: rgba(255, 184, 79, 0.05);
            border: 1px dashed var(--accent-amber);
            padding: 10px;
            margin-bottom: 20px;
            font-size: 0.9rem;
            color: var(--accent-amber);
            text-align: center;
            text-transform: uppercase;
            box-shadow: 0 0 10px rgba(255, 184, 79, 0.1);
            animation: wifipulse 2s infinite ease-in-out;
        }

        @keyframes wifipulse {

            0%,
            100% {
                box-shadow: 0 0 10px rgba(255, 184, 79, 0.1);
                border-style: dashed;
            }

            50% {
                box-shadow: 0 0 20px rgba(255, 184, 79, 0.2);
                border-style: solid;
            }
        }

        .step-header {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.1);
        }

        .step-header span {
            color: var(--accent-cyan);
            font-size: 1.5rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 0 10px rgba(79, 240, 255, 0.4);
        }

        @keyframes wifipulse {

            0%,
            100% {
                box-shadow: 0 0 10px rgba(255, 184, 79, 0.1);
                border-style: dashed;
            }

            50% {
                box-shadow: 0 0 20px rgba(255, 184, 79, 0.2);
                border-style: solid;
            }
        }

        /* --- PIXEL TRANSITION --- */
        .pixel-transition-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 10000;
            pointer-events: none;
            display: grid;
            /* Grid size will be set via JS */
        }

        .pixel-block {
            background-color: var(--accent-cyan);
            opacity: 0;
            image-rendering: pixelated;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* --- LAYOUT --- */
        .app-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 1000px;
            margin: 0 auto;
            padding: 10px;
            z-index: 10;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--panel-bg);
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
        }

        .logo {
            color: var(--accent-cyan);
            text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.5), 0 0 15px rgba(79, 240, 255, 0.5);
        }

        .status-indicator {
            font-size: 1rem;
            color: var(--accent-amber);
        }

        .status-indicator.connected {
            color: var(--accent-green);
        }

        /* --- LOBBY --- */
        .view {
            display: none;
            flex-direction: column;
            flex: 1;
        }

        .view.active {
            display: flex;
        }

        .lobby-controls {
            max-width: 600px;
            margin: 0 auto;
            width: 100%;
        }

        .input-group {
            margin-bottom: 1rem;
        }

        .input-group label {
            display: block;
            color: var(--accent-cyan);
            margin-bottom: 5px;
        }

        .input-group input,
        textarea {
            width: 100%;
            background: #000;
            border: 1px solid var(--text-primary);
            color: var(--accent-green);
            font-family: var(--font-pixel);
            font-size: 1.2rem;
            padding: 10px;
            resize: none;
            /* Disable resize */
            height: 120px;
            /* Fixed height for textareas */
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            border-radius: 0;
        }

        .input-group input {
            height: auto;
            /* Inputs default height */
        }

        textarea#client-answer,
        #client-offer,
        textarea#host-answer {
            margin-top: 10px;
        }


        .tabs {
            display: flex;
            gap: 15px;
            margin-bottom: 2rem;
            perspective: 500px;
        }

        .tab-btn {
            flex: 1;
            padding: 15px;
            cursor: pointer;
            background: #1a1a24;
            color: var(--text-dim);
            border: 2px solid #333;
            font-family: inherit;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 5px 0 #000;
            position: relative;
            top: 0;
            image-rendering: pixelated;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            border-radius: 0;
        }

        .tab-btn.active {
            background: #000;
            color: var(--accent-cyan);
            border-color: var(--accent-cyan);
            transform: translateY(3px);
            box-shadow: 0 2px 0 #000, 0 0 20px rgba(79, 240, 255, 0.4);
            font-weight: bold;
        }

        .tab-btn.active::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 8px solid var(--accent-cyan);
        }

        /* --- LOGO CHIP (HEADER) --- */
        .header-logo-container {
            display: flex;
            align-items: center;
            gap: 12px;
            perspective: 1000px;
        }

        .logo-chip {
            width: 45px;
            height: 45px;
            image-rendering: pixelated;
            transform-style: preserve-3d;
            transform: rotate3d(1, 1, 1, 35deg);
            filter: drop-shadow(4px 4px 0px rgba(0, 0, 0, 0.8)) drop-shadow(0 0 8px rgba(79, 240, 255, 0.4));
            animation: chipfloat 4s infinite ease-in-out;
        }

        @keyframes chipfloat {

            0%,
            100% {
                transform: rotate3d(1, 1, 1, 35deg) translateY(0px);
            }

            50% {
                transform: rotate3d(1, 1, 1, 40deg) translateY(-5px);
            }
        }

        .tab-panel {
            display: none;
            padding: 20px;
            background: var(--panel-bg);
        }

        .tab-panel.active {
            display: block;
        }

        .action-btn {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            cursor: pointer;
            background: var(--accent-amber);
            border: none;
            font-family: inherit;
            font-size: 1.2rem;
            color: black;
            font-weight: bold;
            box-shadow: 0 4px 0 #000, 0 0 10px rgba(255, 184, 79, 0.2);
            transition: all 0.2s;
            text-transform: uppercase;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            border-radius: 0;
        }

        .action-btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #000, 0 0 5px rgba(255, 184, 79, 0.1);
        }

        .btn-primary-highlight {
            background: var(--accent-cyan) !important;
            box-shadow: 0 4px 0 #000, 0 0 15px rgba(79, 240, 255, 0.4) !important;
        }

        .btn-primary-highlight:active {
            box-shadow: 0 2px 0 #000, 0 0 8px rgba(79, 240, 255, 0.2) !important;
        }

        .btn-copy-blue {
            background: #23232f !important;
            color: var(--accent-cyan) !important;
            border: 1px solid var(--accent-cyan) !important;
            box-shadow: 0 4px 0 #000, 0 0 10px rgba(79, 240, 255, 0.1) !important;
        }

        /* --- COMMUNITY CARDS & POT --- */
        .players-area {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            width: 100%;
            padding-bottom: 250px;
            /* Space for fixed footer */
            overflow-y: auto;
        }

        @media (max-width: 600px) {
            .players-area {
                grid-template-columns: 1fr;
            }
        }

        .table-center {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px 0;
            gap: 15px;
        }

        .pot-display {
            font-size: 2.5rem;
            color: var(--accent-amber);
            text-shadow: 0 0 15px rgba(255, 184, 79, 0.6);
            border: 2px solid var(--accent-amber);
            padding: 10px 30px;
            background: #000;
            border-radius: 50px;
            box-shadow: 0 0 20px rgba(255, 184, 79, 0.2), inset 0 0 10px rgba(255, 184, 79, 0.1);
        }

        .community-cards {
            display: flex;
            gap: 15px;
            background: linear-gradient(135deg, #1a4a1a 0%, #0d2a0d 100%);
            padding: 20px 30px;
            border-radius: 15px;
            border: 3px solid #063a06;
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.5), 0 0 20px rgba(79, 255, 134, 0.1);
            position: relative;
            image-rendering: auto;
            /* Smoother gradients for felt */
        }

        .community-cards::after {
            content: '';
            position: absolute;
            top: 5px;
            left: 5px;
            right: 5px;
            bottom: 5px;
            border: 1px dashed rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            pointer-events: none;
        }

        .card-slot {
            width: 65px;
            height: 95px;
            border: 2px dashed rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.2rem;
            color: rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.2);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            perspective: 1000px;
        }

        .card-slot.active {
            border: 2px solid var(--accent-cyan);
            background: var(--accent-cyan);
            color: black;
            box-shadow: 0 0 20px rgba(79, 240, 255, 0.6), inset 0 0 10px rgba(255, 255, 255, 0.5);
            animation: card-deal 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) both, cardfloat 4s infinite ease-in-out 0.6s;
            text-shadow: none;
        }

        @keyframes card-deal {
            0% {
                transform: translateY(-50px) rotateY(90deg) scale(0.5);
                opacity: 0;
            }

            100% {
                transform: translateY(0) rotateY(0deg) scale(1);
                opacity: 1;
            }
        }

        /* Staggered card appearance delays */
        #card-1.active {
            animation-delay: 0.1s, 0.7s;
        }

        #card-2.active {
            animation-delay: 0.3s, 0.9s;
        }

        #card-3.active {
            animation-delay: 0.5s, 1.1s;
        }

        #card-4.active {
            animation-delay: 0.1s, 0.7s;
        }

        /* Resets for Turn */
        #card-5.active {
            animation-delay: 0.1s, 0.7s;
        }

        /* Resets for River */

        @keyframes cardfloat {

            0%,
            100% {
                transform: translateY(0) translateX(0) rotateX(0deg) rotateZ(0deg);
            }

            33% {
                transform: translateY(-4px) translateX(2px) rotateX(2deg) rotateZ(1deg);
            }

            66% {
                transform: translateY(-2px) translateX(-2px) rotateX(1deg) rotateZ(-1deg);
            }
        }

        .card-vibrate {
            animation: cardshuffling 0.5s ease-in-out !important;
            border-color: var(--accent-amber) !important;
            background: var(--accent-amber) !important;
            box-shadow: 0 0 30px var(--accent-amber) !important;
            color: white !important;
        }

        @keyframes cardshuffling {
            0% {
                transform: translateX(0) rotate(0);
            }

            20% {
                transform: translateX(-5px) rotate(-5deg);
            }

            40% {
                transform: translateX(5px) rotate(5deg);
            }

            60% {
                transform: translateX(-3px) rotate(-3deg);
            }

            80% {
                transform: translateX(3px) rotate(3deg);
            }

            100% {
                transform: translateX(0) rotate(0);
            }
        }

        /* --- PLAYER CARDS (HANDS) --- */
        .hand-container {
            background: #15151e;
            border: 2px solid #2a2a35;
            padding: 0;
            display: flex;
            flex-direction: column;
            image-rendering: pixelated;
            box-shadow: 4px 4px 0px #000;
            transition: all 0.2s;
            overflow: hidden;
        }

        .hand-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #23232f;
            padding: 8px 12px;
            border-bottom: 2px solid #000;
            position: relative;
        }

        .hand-name {
            font-size: 1.1rem;
            color: var(--accent-cyan);
            text-transform: uppercase;
            letter-spacing: 1px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .hand-balance {
            font-size: 1rem;
            color: var(--accent-green);
            position: absolute;
            right: 0.5rem;
            transition: all 0.3s ease;
        }

        .hand-status-bar {
            padding: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 45px;
            background: rgba(0, 0, 0, 0.2);
        }

        .status-badge {
            padding: 4px 12px;
            font-size: 0.9rem;
            font-weight: bold;
            letter-spacing: 1px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 2px 2px 0 #000;
        }

        .status-badge.fold {
            background: #444;
            color: #888;
            border-color: #222;
            text-decoration: line-through;
        }

        .status-badge.check {
            background: #1a3a1a;
            color: var(--accent-green);
            border-color: var(--accent-green);
            box-shadow: 0 0 10px rgba(79, 255, 134, 0.2);
        }

        .status-badge.call {
            background: #1a3a3a;
            color: var(--accent-cyan);
            border-color: var(--accent-cyan);
            box-shadow: 0 0 10px rgba(79, 240, 255, 0.2);
        }

        .status-badge.raise {
            background: #3a1a1a;
            color: var(--accent-red);
            border-color: var(--accent-red);
            box-shadow: 0 0 10px rgba(255, 79, 79, 0.3);
        }

        .status-badge.allin {
            background: var(--accent-amber);
            color: #000;
            border-color: #000;
            animation: pulse 1.5s infinite;
            box-shadow: 0 0 15px rgba(255, 184, 79, 0.5);
        }

        .hand-footer {
            padding: 5px 10px 10px 10px;
            background: #000;
            border-top: 1px solid #222;
        }

        .bet-label {
            font-size: 0.7rem;
            color: var(--text-dim);
            text-transform: uppercase;
            margin-bottom: 4px;
            text-align: center;
        }

        @keyframes pulse {
            0% {
                opacity: 0.7;
                box-shadow: 0 0 5px rgba(255, 184, 79, 0.3);
            }

            50% {
                opacity: 1;
                box-shadow: 0 0 20px rgba(255, 184, 79, 0.7);
            }

            100% {
                opacity: 0.7;
                box-shadow: 0 0 5px rgba(255, 184, 79, 0.3);
            }
        }

        /* HOST CONTROLS */
        .host-controls {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
            width: 100%;
        }

        .host-btn {
            border: none;
            padding: 8px 12px;
            cursor: pointer;
            font-family: inherit;
            font-size: 1rem;
            color: black;
            flex: 1;
            min-width: 120px;
        }

        /* PLAYER CONTROLS (Fixed Footer Dashboard) */
        .game-controls {
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            padding: 15px 25px;
            border-top: 3px solid var(--accent-cyan);
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 100;
            gap: 20px;
            box-shadow: 0 -10px 30px rgba(79, 240, 255, 0.15), 0 -2px 10px rgba(79, 240, 255, 0.3);
            border-image: linear-gradient(to right, transparent, var(--accent-cyan), transparent) 1;
        }

        /* Pure CSS neon border replacement since border-image and border-top don't mix well for simple borders */
        .game-controls::before {
            content: '';
            position: absolute;
            top: -2px;
            left: 0;
            width: 100%;
            height: 3px;
            background: var(--accent-cyan);
            box-shadow: 0 0 15px var(--accent-cyan), 0 0 30px rgba(79, 240, 255, 0.5);
        }

        /* My Stat Box in Footer */
        .my-stats-box {
            background: rgba(26, 26, 36, 0.8);
            border: 2px solid var(--accent-green);
            padding: 12px 18px;
            min-width: 200px;
            text-align: left;
            display: flex;
            flex-direction: column;
            gap: 4px;
            box-shadow: 0 0 15px rgba(79, 255, 134, 0.1), inset 0 0 10px rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .my-stats-box::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(79, 255, 134, 0.05) 0%, transparent 100%);
            pointer-events: none;
        }

        .my-chip-total {
            font-size: 1.8rem;
            color: var(--accent-green);
            font-weight: bold;
            text-shadow: 0 0 10px rgba(79, 255, 134, 0.4);
        }

        /* CHIP BUTTONS */
        .chip-selector {
            display: flex;
            gap: 12px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 50px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chip-btn {
            width: 52px;
            height: 52px;
            border-radius: 50%;
            border: 4px dashed rgba(0, 0, 0, 0.3);
            cursor: pointer;
            font-family: var(--font-pixel);
            font-weight: bold;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            justify-content: center;
            color: black;
            transition: all 0.2s cubic-bezier(0.18, 0.89, 0.32, 1.28);
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.5);
            text-shadow: 1px 1px 0 rgba(255, 255, 255, 0.5);
            position: relative;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            user-select: none;
        }

        .chip-btn:hover {
            transform: translateY(-4px) scale(1.1);
            filter: brightness(1.2);
            box-shadow: 0 8px 0 rgba(0, 0, 0, 0.5);
        }

        .chip-btn:active {
            transform: translateY(2px) scale(0.95);
            box-shadow: 0 2px 0 rgba(0, 0, 0, 0.5);
        }

        .c1 {
            background: #eeeeee;
            border-color: #bbbbbb;
        }

        .c5 {
            background: var(--accent-red);
            border-color: #a00000;
            color: white;
            text-shadow: 1px 1px 0 #000;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.5), 0 0 10px rgba(255, 79, 79, 0.2);
        }

        .c10 {
            background: var(--accent-cyan);
            border-color: #005f73;
            color: black;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.5), 0 0 10px rgba(79, 240, 255, 0.2);
        }

        .c25 {
            background: var(--accent-green);
            border-color: #008000;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.5), 0 0 10px rgba(79, 255, 134, 0.2);
        }

        .c100 {
            background: #333333;
            border-color: #000000;
            color: var(--accent-amber);
            text-shadow: 1px 1px 0 #000;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.5), 0 0 10px rgba(255, 184, 79, 0.2);
        }



        /* PLAYER CHIPS ON BOARD */
        .chips-row {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 2px;
            margin-top: 5px;
            height: 25px;
            /* Fixed height to keep layout stable */
        }

        .chip {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px dashed rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.6rem;
            font-weight: bold;
            color: black;
            font-family: var(--font-pixel);
            box-shadow: 1px 2px 0 rgba(0, 0, 0, 0.5);
        }

        .chip.white {
            background: #eeeeee;
            border-color: #ccc;
        }

        .chip.red {
            background: var(--accent-red);
            border-color: #900;
            color: white;
        }

        .chip.blue {
            background: var(--accent-cyan);
            border-color: #005f73;
        }

        .chip.green {
            background: var(--accent-green);
            border-color: #060;
        }

        .chip.black {
            background: #333;
            border-color: #000;
            color: var(--accent-amber);
        }

        .action-bar {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            width: 100%;
        }

        .control-btn {
            padding: 12px 5px;
            font-family: var(--font-pixel);
            font-size: 0.85rem;
            cursor: pointer;
            border: 2px solid #555;
            background: #222;
            color: #eee;
            transition: all 0.2s;
            text-transform: uppercase;
            box-shadow: 3px 3px 0 #000;
            display: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            border-radius: 0;
            -webkit-user-select: none;
            -moz-user-select: none;
            user-select: none;
            /* Hidden by default, JS will show appropriate ones */
        }

        .control-btn:hover {
            filter: brightness(1.2);
            transform: translate(-1px, -1px);
            box-shadow: 4px 4px 0 #000;
        }

        /* Specific Button Colors - Unique Identification */
        .btn-pasar {
            background: #ffb84f;
            border-color: #fff;
            color: #000;
            font-weight: bold;
            box-shadow: 0 0 20px rgba(255, 184, 79, 0.6), 3px 3px 0 #000;
        }

        .btn-apostar {
            background: #4fff86;
            border-color: #fff;
            color: #000;
            font-weight: bold;
            box-shadow: 0 0 20px rgba(79, 255, 134, 0.8), 3px 3px 0 #000;
        }

        .btn-igualar {
            background: #4ff0ff;
            border-color: #fff;
            color: #000;
            font-weight: bold;
            box-shadow: 0 0 20px rgba(79, 240, 255, 0.6), 3px 3px 0 #000;
        }

        .btn-subir {
            background: #d64fff;
            border-color: #fff;
            color: #000;
            font-weight: bold;
            box-shadow: 0 0 20px rgba(214, 79, 255, 0.6), 3px 3px 0 #000;
        }

        .btn-retirarse {
            background: #ff4f4f;
            border-color: #fff;
            color: #000;
            font-weight: bold;
            box-shadow: 0 0 20px rgba(255, 79, 79, 0.6), 3px 3px 0 #000;
        }

        .btn-limpiar {
            border-color: #aaa;
            color: #fff;
            background: #444;
            box-shadow: 3px 3px 0 #000;
        }

        .btn-limpiar:hover {
            background: #666;
        }

        /* STATUS BADGES Synchronization */
        .status-badge {
            padding: 4px 8px;
            font-size: 0.7rem;
            font-family: var(--font-pixel);
            text-transform: uppercase;
            font-weight: bold;
            display: inline-block;
            box-shadow: 2px 2px 0 #000;
            color: #000;
        }

        .status-badge.check {
            background: none;
            color: #ffb84f;
            box-shadow: none;
        }

        .status-badge.bet {
            background: #4fff86;
            box-shadow: 0 0 10px rgba(79, 255, 134, 0.4), 2px 2px 0 #000;
        }

        .status-badge.call {
            background: none;
            color: #4ff0ff;
            box-shadow: 0 0 10px rgba(79, 240, 255, 0.4), 2px 2px 0 #000;
            padding: 2px 6px;
            border: 1px solid rgba(79, 240, 255, 0.3);
        }

        .status-badge.raise {
            background: #d64fff;
            box-shadow: 0 0 10px rgba(214, 79, 255, 0.4), 2px 2px 0 #000;
        }

        .status-badge.fold {
            background: #ff4f4f;
            box-shadow: 0 0 10px rgba(255, 79, 79, 0.4), 2px 2px 0 #000;
        }

        .status-badge.allin {
            background: #ff4fff;
            box-shadow: 0 0 15px rgba(255, 79, 255, 0.6), 2px 2px 0 #000;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.05);
                opacity: 0.8;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Winner Celebration CSS */
        .winner-alert {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--accent-amber);
            color: #000;
            padding: 5px 15px;
            font-weight: bold;
            font-size: 1.2rem;
            box-shadow: 0 0 20px rgba(255, 184, 79, 0.8), 4px 4px 0 #000;
            z-index: 10;
            white-space: nowrap;
            animation: float-up 0.5s cubic-bezier(0.18, 0.89, 0.32, 1.28);
        }

        @keyframes float-up {
            0% {
                transform: translateX(-50%) translateY(20px);
                opacity: 0;
            }

            100% {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }

        .winner-pulse {
            animation: winner-glow 1s infinite alternate;
            border-color: var(--accent-amber) !important;
        }

        @keyframes winner-glow {
            from {
                box-shadow: 0 0 10px rgba(255, 184, 79, 0.3);
            }

            to {
                box-shadow: 0 0 30px rgba(255, 184, 79, 0.8);
            }
        }

        /* Stack Counter styling */
        .chip-stack-count {
            font-family: var(--font-pixel);
            font-size: 0.8rem;
            color: white;
            margin-left: 2px;
            align-self: center;
            text-shadow: 1px 1px 0 #000;
        }

        .action-bar {
            display: flex;
            gap: 10px;
            width: 100%;
            justify-content: center;
            flex-wrap: wrap;
        }

        /* --- MOBILE OPTIMIZATION --- */
        @media (max-width: 768px) {
            .players-area {
                grid-template-columns: repeat(2, 1fr) !important;
                /* Force 2 cols to override previous rules */
                gap: 10px;
                padding-bottom: 350px;
                /* Increased space for tall footer */
            }

            .hand-container {
                min-width: unset;
                padding: 10px;
            }

            .community-cards {
                gap: 5px;
            }

            .card-slot {
                width: 40px;
                height: 60px;
                font-size: 1.5rem;
            }

            .game-controls {
                flex-direction: column;
                gap: 10px;
                padding: 10px;
            }

            .my-stats-box {
                width: 100%;
                min-width: unset;
                flex-direction: row;
                align-items: center;
                justify-content: space-between;
                padding: 5px 10px;
            }

            .chip-selector {
                gap: 5px;
                justify-content: center;
            }

            .chip-btn {
                width: 40px;
                height: 40px;
                font-size: 0.7rem;
            }

            .action-bar {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 8px;
            }

            .action-btn {
                font-size: 0.9rem;
                padding: 10px;
            }
        }

        .control-btn {
            padding: 15px 10px;
            font-size: 1.2rem;
            cursor: pointer;
            font-family: inherit;
            border: none;
            flex: 1;
            min-width: 100px;
            color: black;
            font-weight: bold;
            text-transform: uppercase;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.5);
            transition: all 0.2s;
        }

        .control-btn:hover {
            filter: brightness(1.1);
            transform: translateY(-2px);
        }

        .control-btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 rgba(0, 0, 0, 0.5);
        }

        .btn-fold {
            background: var(--text-dim);
            color: white;
        }

        .btn-check {
            background: var(--accent-green);
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.5), 0 0 15px rgba(79, 255, 134, 0.3);
        }

        .btn-call {
            background: var(--accent-cyan);
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.5), 0 0 15px rgba(79, 240, 255, 0.3);
        }

        .btn-raise {
            background: var(--accent-red);
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.5), 0 0 15px rgba(255, 79, 79, 0.3);
        }

        /* SWEETALERT2 PIXEL FONT OVERRIDE */
        div:where(.swal2-container) div:where(.swal2-popup) {
            font-family: var(--font-pixel) !important;
            font-size: 1.2rem !important;
            border-radius: 0 !important;
            border: 4px solid white !important;
            background: #111 !important;
            color: white !important;
            box-shadow: 10px 10px 0 rgba(0, 0, 0, 0.8) !important;
        }

        div:where(.swal2-container) .swal2-title {
            font-family: var(--font-pixel) !important;
            color: var(--accent-cyan) !important;
            text-transform: uppercase;
        }

        div:where(.swal2-container) .swal2-html-container {
            font-family: var(--font-pixel) !important;
            color: #ddd !important;
        }

        /* Pixelify icons */
        div:where(.swal2-container) .swal2-icon {
            border-radius: 0 !important;
            border-width: 4px !important;
            transform: scale(0.9);
        }

        .swal2-icon.swal2-success [class^=swal2-success-line] {
            background-color: var(--accent-green) !important;
        }

        .swal2-icon.swal2-success .swal2-success-ring {
            border-color: rgba(0, 255, 0, 0.3) !important;
            border-radius: 0 !important;
        }

        div:where(.swal2-container) .swal2-styled {
            font-family: var(--font-pixel) !important;
            border-radius: 0 !important;
            text-transform: uppercase;
            letter-spacing: 1px;
            border: 2px solid white !important;
            box-shadow: 3px 3px 0 rgba(0, 0, 0, 0.5) !important;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        /* Make confirm button text black for better readability */
        div:where(.swal2-container) .swal2-confirm {
            color: #000 !important;
            background-color: var(--accent-cyan) !important;
            font-weight: bold !important;
        }

        div:where(.swal2-container) .swal2-confirm:focus {
            box-shadow: 0 0 0 3px rgba(79, 240, 255, 0.5) !important;
        }

        div:where(.swal2-container) .swal2-cancel {
            background-color: var(--text-dim) !important;
            color: white !important;
        }
    </style>
</head>

<body>
    <div class="crt-overlay">
        <div class="scanlines"></div>
        <div class="vignette"></div>
    </div>

    <!-- Pixel Transition Overlay -->
    <div id="pixel-transition" class="pixel-transition-container"></div>

    <main class="app-container">
        <header class="game-header">
            <div class="header-logo-container">
                <img src="../../img/logoPB.png" alt="PB" class="logo-chip">
                <h1 class="logo">PIXEL BET</h1>
            </div>
            <div style="display:flex; gap:10px; align-items:center;">
                <button id="btn-exit-game" onclick="window.app.exitGame()" class="action-btn"
                    style="display:none; width:auto; padding:5px 10px; font-size:1rem; background:var(--accent-red); color:white; border:1px solid white;">SALIR
                    ✕</button>
                <div id="connection-status" class="status-indicator">OFFLINE</div>
            </div>
        </header>

        <!-- LOBBY -->
        <section id="view-lobby" class="view active">
            <div class="lobby-controls">
                <div class="wifi-notice">
                    IMPORTANTE: Todos los jugadores deben estar en la misma red Wi-Fi
                </div>
                <div class="input-group">
                    <label>NOMBRE</label>
                    <input type="text" id="player-name-input" placeholder="Tu Nombre" maxlength="10">
                </div>
                <div class="tabs">
                    <button class="tab-btn active" data-tab="host">CREAR (HOST)</button>
                    <button class="tab-btn" data-tab="join">UNIRSE</button>
                </div>
                <!-- HOST -->
                <div id="panel-host" class="tab-panel active">
                    <div
                        style="border:1px solid var(--accent-cyan); padding:15px; margin-bottom:15px; background:rgba(0,0,255,0.05)">
                        <div class="step-header">
                            <div class="step-badge">1</div> <span>Crear Invitación</span>
                        </div>
                        <p class="instruction">Haz clic en generar y espera a que aparezca el código.</p>
                        <button id="btn-init-host" class="action-btn btn-primary-highlight"
                            style="background:var(--accent-cyan); color:black;">GENERAR CÓDIGO DE HOST</button>
                        <textarea id="host-offer" readonly placeholder="El código aparecerá aquí..."></textarea>
                        <div style="display:flex; gap:5px;">
                            <button id="btn-copy-offer" class="action-btn btn-copy-blue">COPIAR</button>
                            <button onclick="window.app.showQR('host-offer')" class="action-btn"
                                style="background:#fff; color:black">VER QR</button>
                        </div>
                    </div>

                    <div style="border:1px solid var(--accent-green); padding:15px; background:rgba(0,255,0,0.05)">
                        <div class="step-header">
                            <div class="step-badge">2</div> <span>Confirmar Conexión</span>
                        </div>
                        <p class="instruction">Tu amigo te enviará un código de respuesta. Pégalo aquí:</p>
                        <textarea id="host-answer" placeholder="Pega aquí la RESPUESTA de tu amigo..."></textarea>
                        <div style="display:flex; gap:5px;">
                            <button id="btn-connect-host" class="action-btn"
                                style="background:var(--accent-green); color:black;">CONECTAR JUGADOR</button>
                            <button onclick="window.app.startQRScanner('host-answer')" class="action-btn"
                                style="background:var(--accent-amber); color:black">ESCANEAR QR</button>
                        </div>
                    </div>
                </div>
                <!-- JOIN -->
                <div id="panel-join" class="tab-panel">
                    <div
                        style="border:1px solid var(--accent-cyan); padding:15px; margin-bottom:15px; background:rgba(0,0,255,0.05)">
                        <div class="step-header">
                            <div class="step-badge">1</div> <span>Pegar Invitación</span>
                        </div>
                        <p class="instruction">Pega el código que te envió el Host y genera tu respuesta:</p>
                        <textarea id="client-offer" placeholder="Pega la INVITACIÓN del host aquí..."></textarea>
                        <div style="display:flex; gap:5px;">
                            <button id="btn-generate-answer" class="action-btn"
                                style="background:var(--accent-cyan); color:black;">GENERAR MI RESPUESTA</button>
                            <button onclick="window.app.startQRScanner('client-offer')" class="action-btn"
                                style="background:var(--accent-amber); color:black">ESCANEAR QR</button>
                        </div>
                    </div>

                    <div style="border:1px solid var(--accent-green); padding:15px; background:rgba(0,255,0,0.05)">
                        <div class="step-header">
                            <div class="step-badge">2</div> <span>Enviar al Host</span>
                        </div>
                        <p class="instruction">Copia tu respuesta y envíasela al Host:</p>
                        <textarea id="client-answer" readonly placeholder="Tu respuesta aparecerá aquí..."></textarea>
                        <div style="display:flex; gap:5px;">
                            <button id="btn-copy-answer" class="action-btn btn-copy-blue" style="width:100%;">COPIAR MI
                                RESPUESTA</button>
                            <button onclick="window.app.showQR('client-answer')" class="action-btn"
                                style="background:#fff; color:black">VER QR</button>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- CHIP TABLE -->
        <section id="view-game" class="view hidden">
            <!-- HOST INVITE TOOL (Overlay) -->
            <div id="invite-overlay" class="crt-overlay"
                style="background:rgba(0,0,0,0.95); display:none; flex-direction:column; align-items:center; justify-content:center; padding:20px; z-index:3000; pointer-events:auto;">
                <h2 style="color:var(--accent-cyan); margin-bottom:1rem;">INVITAR JUGADOR</h2>
                <div
                    style="border:1px solid var(--accent-cyan); padding:20px; width:100%; max-width:500px; background:var(--panel-bg)">
                    <p style="color:var(--text-dim)">1. Genera código para el NUEVO jugador:</p>
                    <button id="btn-ingame-gen" class="action-btn btn-primary-highlight"
                        style="background:var(--accent-cyan); color:black;">GENERAR CÓDIGO</button>
                    <textarea id="ingame-offer" readonly placeholder="..." style="height:60px;"></textarea>
                    <div style="display:flex; gap:5px;">
                        <button id="btn-ingame-copy" class="action-btn btn-copy-blue">COPIAR</button>
                        <button id="btn-ingame-qr" onclick="window.app.showQR('ingame-offer')" class="action-btn"
                            style="background:#fff; color:black">VER QR</button>
                    </div>

                    <p style="color:var(--text-dim); margin-top:10px;">2. Pega su respuesta:</p>
                    <textarea id="ingame-answer" placeholder="..." style="height:60px;"></textarea>
                    <div style="display:flex; gap:5px;">
                        <button id="btn-ingame-connect" class="action-btn"
                            style="background:var(--accent-green); color:black;">CONECTAR</button>
                        <button id="btn-ingame-scan" onclick="window.app.startQRScanner('ingame-answer')"
                            class="action-btn" style="background:var(--accent-amber); color:black">ESCANEAR QR</button>
                    </div>
                </div>
                <button id="btn-close-invite" class="action-btn"
                    style="margin-top:20px;background:#333; width:100%; max-width:500px;">CERRAR</button>
            </div>

            <!-- FEEDBACK OVERLAY -->
            <div id="connecting-overlay" class="crt-overlay"
                style="background:rgba(0,0,0,0.85); display:none; flex-direction:column; align-items:center; justify-content:center; z-index:9999;">
                <div style="text-align:center;">
                    <div
                        style="border: 4px solid rgba(255,255,255,0.1); border-top: 4px solid var(--accent-cyan); border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; display:inline-block; margin-bottom:15px;">
                    </div>
                    <h2 id="overlay-title" style="color:var(--accent-cyan); margin-bottom:5px;">CONECTANDO...</h2>
                    <p id="overlay-msg" style="color:var(--text-dim); font-size:0.9rem;">Estableciendo túnel P2P</p>
                </div>
            </div>

            <div class="game-table">
                <!-- Center Info: Pot & Community Cards -->
                <div class="table-center">
                    <div style="color:var(--text-dim)">BOTE ACTUAL</div>
                    <div id="pot-display" class="pot-display">BOTE: $0</div>
                    <div id="pot-chips" class="chips-row" style="height:auto; min-height:25px; transform:scale(0.9);">
                    </div>

                    <div class="community-cards">
                        <div id="card-1" class="card-slot">?</div>
                        <div id="card-2" class="card-slot">?</div>
                        <div id="card-3" class="card-slot">?</div>
                        <div id="card-4" class="card-slot">?</div>
                        <div id="card-5" class="card-slot">?</div>
                    </div>
                    <div id="phase-display" style="color:var(--accent-cyan); font-size:1.5rem;">ESPERANDO</div>
                </div>

                <div style="text-align:center; padding:20px;">
                    <button id="btn-show-invite" class="action-btn"
                        style="width:auto; padding:5px 20px; display:none;">+ INVITAR</button>
                    <!-- Host Round Controls -->
                    <div id="host-round-controls"
                        style="display:none; margin-top:10px; gap:10px; justify-content:center;">
                        <button id="btn-distribute-pot" onclick="window.app.hostDistributePot()" class="action-btn"
                            style="width:auto; background:var(--accent-green); color:black; display:none;">DISTRIBUIR
                            BOTE</button>
                        <button id="btn-next-phase" onclick="window.app.hostNextPhase()" class="action-btn"
                            style="width:auto; background:var(--accent-cyan); color:black">SIGUIENTE FASE >></button>
                        <button onclick="window.app.hostResetRound()" class="action-btn"
                            style="width:auto; background:var(--accent-red)">NUEVA PARTIDA</button>
                    </div>
                </div>

                <!-- Players Grid -->
                <div class="players-area" id="players-list">
                    <!-- Player Items injected here -->
                </div>
            </div>

            <!-- CONTROLS FOOTER -->
            <div class="game-controls" id="player-controls">

                <!-- 1. MY INFO (Moved here) -->
                <div id="my-player-stats" class="my-stats-box">
                    <span style="color:var(--text-dim); font-size:0.9rem">MI JUGADOR</span>
                    <span id="my-name-disp" style="color:white; font-weight:bold">...</span>
                    <div id="my-chips-disp" class="my-chip-total">$0</div>
                </div>

                <!-- 2. BETTING CONTROLS -->
                <div id="betting-ui" style="display:flex; flex-direction:column; align-items:center; flex:1;">

                    <div class="chip-selector">
                        <button class="chip-btn c1" onclick="window.app.addChip(1)">$1</button>
                        <button class="chip-btn c5" onclick="window.app.addChip(5)">$5</button>
                        <button class="chip-btn c10" onclick="window.app.addChip(10)">$10</button>
                        <button class="chip-btn c25" onclick="window.app.addChip(25)">$25</button>
                        <button class="chip-btn c100" onclick="window.app.addChip(100)">$100</button>
                    </div>
                </div>

                <!-- 3. ACTIONS -->
                <div style="display:flex; flex-direction:column; width:220px; gap:8px;">
                    <div style="text-align:right; margin-bottom:2px;">
                        <span style="color:var(--text-dim); font-size: 0.8rem;">CANTIDAD SELECCIONADA: </span>
                        <span id="my-pending-bet" style="color:var(--accent-amber); font-size:1.5rem">$0</span>
                    </div>

                    <div class="action-bar" id="betting-actions">
                        <!-- Strict Texas Hold'em Flow Buttons -->
                        <button id="btn-pasar" class="control-btn btn-pasar"
                            onclick="window.app.doCheck()">PASAR</button>
                        <button id="btn-apostar" class="control-btn btn-apostar"
                            onclick="window.app.doBet()">APOSTAR</button>
                        <button id="btn-igualar" class="control-btn btn-igualar"
                            onclick="window.app.doCall()">IGUALAR</button>
                        <button id="btn-subir" class="control-btn btn-subir"
                            onclick="window.app.doRaise()">SUBIR</button>
                        <button id="btn-retirarse" class="control-btn btn-retirarse"
                            onclick="window.app.doFold()">RETIRARSE</button>
                        <button id="btn-limpiar" class="control-btn btn-limpiar"
                            onclick="window.app.clearPendingBet()">X (LIMPIAR)</button>
                    </div>
                </div>
            </div>
        </section>
        </div>
        </section>

        <!-- QR MODALS -->
        <!-- QR MODALS -->
        <div id="modal-qr-show" class="view hidden"
            style="position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:4000; display:none; flex-direction:column; align-items:center; justify-content:center;">
            <div style="background:white; padding:20px; text-align:center; max-width:90%;">
                <h3 style="color:black; margin-bottom:10px; font-family:var(--font-pixel);">CÓDIGO QR</h3>
                <div id="qr-code-container" style="display:flex; justify-content:center;"></div>
                <p style="color:#333; margin-top:15px; font-size:1rem; line-height:1.4;">
                    Usa <b>Google Lens</b> o tu <b>Cámara</b><br>para escanear y copiar el texto.
                </p>
            </div>
            <button onclick="document.getElementById('modal-qr-show').style.display='none'" class="action-btn"
                style="width:200px; margin-top:20px; background:var(--accent-red)">CERRAR</button>
        </div>

        <!-- QR SCANNER MODAL -->
        <div id="modal-qr-scanner" class="view hidden"
            style="position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.95); z-index:4000; display:none; flex-direction:column; align-items:center; justify-content:center; padding:20px;">
            <div
                style="background:var(--panel-bg); padding:20px; text-align:center; max-width:500px; width:100%; border:2px solid var(--accent-cyan);">
                <h3 style="color:var(--accent-cyan); margin-bottom:10px; font-family:var(--font-pixel);">ESCANEAR QR
                </h3>
                <p style="color:var(--text-dim); margin-bottom:15px; font-size:0.9rem;">Apunta la cámara al código QR
                </p>

                <!-- Camera feed container -->
                <div id="qr-reader" style="width:100%; max-width:400px; margin:0 auto;"></div>

                <p id="qr-scan-status" style="color:var(--accent-amber); margin-top:10px; min-height:20px;"></p>
            </div>
            <button onclick="window.app.stopQRScanner()" class="action-btn"
                style="width:200px; margin-top:20px; background:var(--accent-red)">CERRAR</button>
        </div>

    </main>

    <script>
        class PixelTransition {
            constructor(gridSize = 10) {
                this.container = document.getElementById('pixel-transition');
                this.gridSize = gridSize;
                this.pixels = [];
                this.init();
            }

            init() {
                this.container.style.gridTemplateColumns = `repeat(${this.gridSize}, 1fr)`;
                this.container.style.gridTemplateRows = `repeat(${this.gridSize}, 1fr)`;
                this.container.innerHTML = '';
                this.pixels = [];
                for (let i = 0; i < this.gridSize * this.gridSize; i++) {
                    const p = document.createElement('div');
                    p.className = 'pixel-block';
                    this.container.appendChild(p);
                    this.pixels.push(p);
                }
            }

            async play(callback) {
                this.container.style.pointerEvents = 'all';
                // Reset pixels
                gsap.set(this.pixels, { opacity: 0 });

                // Phase 1: Pixels pixels in
                await gsap.to(this.pixels, {
                    opacity: 1,
                    duration: 0.1,
                    stagger: { amount: 0.5, from: "random" }
                });

                // MIDDLE: Execution callback
                if (callback) await callback();

                // Phase 2: Pixels out
                await gsap.to(this.pixels, {
                    opacity: 0,
                    duration: 0.1,
                    delay: 0.2, // Small pause at full pixelation
                    stagger: { amount: 0.5, from: "random" }
                });

                this.container.style.pointerEvents = 'none';
            }
        }

        /**
         * NetworkManager (Multi-Peer Edition)
         * Supports multiple sequential connections for the Host.
         */
        class NetworkManager {
            constructor() {
                // connections: Array of { pc: RTCPeerConnection, dc: DataChannel, id: string }
                this.peers = [];
                this.isHost = false;
                this.onMessage = null;
                this.onConnectionOpen = null;
                this.onHostDisconnect = null; // NEW callback

                this.config = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        // Free TURN servers for better NAT traversal (PC-Mobile connections)
                        {
                            urls: 'turn:openrelay.metered.ca:80',
                            username: 'openrelayproject',
                            credential: 'openrelayproject'
                        },
                        {
                            urls: 'turn:openrelay.metered.ca:443',
                            username: 'openrelayproject',
                            credential: 'openrelayproject'
                        }
                    ]
                };
            }

            _createPeer() {
                const pc = new RTCPeerConnection(this.config);
                const peerObj = { pc, dc: null, id: Math.random().toString(36).substr(2, 9) };

                pc.onconnectionstatechange = () => {
                    console.log(`[${peerObj.id}] State:`, pc.connectionState);
                };

                // DETECT DISCONNECTION
                pc.oniceconnectionstatechange = () => {
                    console.log(`[${peerObj.id}] ICE State:`, pc.iceConnectionState);

                    // Only trigger disconnect on PERMANENT failures
                    // 'disconnected' is a TEMPORARY state during ICE negotiation and should not trigger error
                    // 'failed' = permanent failure, connection cannot be established
                    // 'closed' = connection was closed intentionally
                    if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'closed') {
                        if (!this.isHost && this.onHostDisconnect) {
                            this.onHostDisconnect();
                        }
                    }
                };

                return peerObj;
            }

            async waitForIce(pc) {
                if (pc.iceGatheringState === 'complete') return;
                const p = new Promise(r => {
                    const check = () => {
                        if (pc.iceGatheringState === 'complete') {
                            pc.removeEventListener('icegatheringstatechange', check);
                            r();
                        }
                    };
                    pc.addEventListener('icegatheringstatechange', check);
                });
                // Increased timeout to 5 seconds for mobile networks
                const t = new Promise(r => setTimeout(r, 5000));
                return Promise.race([p, t]);
            }

            // --- HOST METHODS ---

            async createHost(onSignalReady) {
                this.isHost = true;

                // Create a NEW peer for this new connection attempt
                const peer = this._createPeer();
                this.peers.push(peer);

                // Host creates the DataChannel for this peer
                peer.dc = peer.pc.createDataChannel("gameData");
                this._setupDataChannel(peer.dc);

                const offer = await peer.pc.createOffer();
                await peer.pc.setLocalDescription(offer);

                console.log("Waiting for ICE...");
                await this.waitForIce(peer.pc);

                onSignalReady(JSON.stringify(peer.pc.localDescription));
            }

            async finalizeHostConnection(answerSDP) {
                // Find the most recent peer that is waiting for remote description (signalingState is 'have-local-offer')
                // OR simply the last one added? 
                // Serial assumption: The host follows steps 1 connection at a time.
                const peer = this.peers.slice().reverse().find(p => p.pc.signalingState === 'have-local-offer');

                if (!peer) {
                    console.error("No pending peer connection found!");
                    return;
                }

                const answerDesc = new RTCSessionDescription(JSON.parse(answerSDP));
                await peer.pc.setRemoteDescription(answerDesc);
            }

            // --- CLIENT METHODS ---

            async joinGame(offerSDP, onSignalReady) {
                this.isHost = false;
                const peer = this._createPeer();
                this.peers = [peer]; // Client only has one connection (to Host)

                peer.pc.ondatachannel = (event) => {
                    peer.dc = event.channel;
                    this._setupDataChannel(peer.dc);
                };

                const offerDesc = new RTCSessionDescription(JSON.parse(offerSDP));
                await peer.pc.setRemoteDescription(offerDesc);

                const answer = await peer.pc.createAnswer();
                await peer.pc.setLocalDescription(answer);

                console.log("Waiting for ICE...");
                await this.waitForIce(peer.pc);

                onSignalReady(JSON.stringify(peer.pc.localDescription));
            }

            // --- SHARED ---

            shared_setupDataChannel(dc) {
                dc.onopen = () => {
                    console.log("✅ DataChannel OPEN - Ready to send/receive");
                    // Trigger connection open ONLY when we can actually send data
                    if (this.onConnectionOpen) this.onConnectionOpen(dc);
                };
                dc.onmessage = (event) => {
                    console.log("📨 Message received:", event.data);
                    const msg = JSON.parse(event.data);
                    console.log("📨 Parsed message type:", msg.type);
                    if (this.onMessage) this.onMessage(msg);
                };
            }

            _setupDataChannel(dc) {
                this.shared_setupDataChannel(dc);
            }

            send(type, payload) {
                const msg = JSON.stringify({ type, ...payload });
                this.peers.forEach(p => {
                    if (p.dc && p.dc.readyState === 'open') {
                        p.dc.send(msg);
                    }
                });
            }
        }

        /**
         * GameState - PIXEL POKER EDITION
         * Host manages the truth.
         */
        class GameState {
            constructor(networkManager, uiController) {
                this.net = networkManager;
                this.ui = uiController;

                this.PHASES = ['PREFLOP', 'FLOP', 'TURN', 'RIVER', 'RESOLUCION'];

                this.myId = Math.random().toString(36).substr(2, 9);
                this.players = [];
                // { id, name, chips: 550, currentBet: 0, status: 'ACTIVE'|'FOLDED'|'ALLIN', totalBetThisHand: 0 }

                this.pot = 0;
                this.phaseIndex = 0; // 0=Preflop, 1=Flop...

                this.isHost = false;
                this.pendingName = "";

                this.net.onMessage = (msg) => this.handleMessage(msg);
                this.net.onConnectionOpen = () => this.onConnected();
                this.net.onHostDisconnect = () => this.handleHostDisconnect();
            }

            handleHostDisconnect() {
                Swal.fire({
                    title: '¡HOST DESCONECTADO!',
                    text: 'El anfitrión ha cerrado la partida.',
                    icon: 'error',
                    background: '#1a1a24',
                    color: '#e0e0e0',
                    confirmButtonColor: '#ff4f4f',
                    confirmButtonText: 'RECARGAR PÁGINA',
                    allowOutsideClick: false,
                    allowEscapeKey: false
                }).then(() => {
                    window.location.reload();
                });
            }

            // --- SETUP ---
            initHost(name) {
                this.isHost = true;

                // Check if player already exists (e.g., if host reloads page)
                const existingPlayer = this.players.find(p => p.id === this.myId);
                if (!existingPlayer) {
                    this.addPlayer({ id: this.myId, name: name });
                } else {
                    existingPlayer.name = name; // Update name if it changed
                }

                if (window.app && window.app.transition) {
                    window.app.transition(() => {
                        this.ui.showGame();
                        this.ui.updateLobbyStatus("ESPERANDO JUGADORES...");
                        this.ui.setHostMode(true);
                    });
                } else {
                    this.ui.showGame();
                    this.ui.updateLobbyStatus("ESPERANDO JUGADORES...");
                    this.ui.setHostMode(true);
                }
                this.broadcastState();
            }

            initClient(name) {
                this.isHost = false;
                this.pendingName = name;
                this.ui.setHostMode(false);
            }

            onConnected() {
                console.log("🔗 onConnected callback triggered. isHost:", this.isHost);
                this.ui.updateLobbyStatus("CONECTADO");
                this.ui.hideOverlay();
                // window.app.msg removed for smoother flow

                if (!this.isHost) {
                    console.log("👤 CLIENT: Sending JOIN message with name:", this.pendingName);
                    this.net.send('JOIN', { id: this.myId, name: this.pendingName });

                    if (window.app && window.app.transition) {
                        window.app.transition(() => this.ui.showGame());
                    } else {
                        this.ui.showGame();
                    }
                } else {
                    console.log("🏠 HOST: Already in game, waiting for clients");
                }
            }

            // --- MESSAGE HANDLING ---
            handleMessage(msg) {
                console.log("🎮 handleMessage called. isHost:", this.isHost, "msgType:", msg.type);
                if (this.isHost) {
                    switch (msg.type) {
                        case 'JOIN':
                            console.log("🏠 HOST: Received JOIN from", msg.name, "(ID:", msg.id, ")");
                            this.addPlayer({ id: msg.id, name: msg.name });
                            console.log("🏠 HOST: Player added. Total players:", this.players.length);
                            this.broadcastState();
                            break;
                        case 'ACTION':
                            this.handlePlayerAction(msg.id, msg.action, msg.amount);
                            break;
                    }
                } else {
                    if (msg.type === 'STATE_UPDATE') {
                        console.log("👤 CLIENT: Received STATE_UPDATE");
                        this.syncState(msg.state);
                    } else if (msg.type === 'WIN_ANIM') {
                        this.ui.triggerWinAnimation();
                    } else if (msg.type === 'HOST_EXIT') {
                        this.handleHostDisconnect();
                    } else if (msg.type === 'WINNER_CELEBRATION') {
                        this.ui.showWinnerCelebration(msg.winners);
                    }
                }
            }

            broadcastHostExit() {
                if (this.isHost) {
                    console.log("🏠 HOST: Broadcasting exit to all peers");
                    this.net.send('HOST_EXIT', {});
                }
            }

            // --- CORE LOGIC (HOST) ---
            addPlayer(data) {
                console.log("➕ addPlayer called with:", data);
                if (!this.players.find(p => p.id === data.id)) {
                    // INITIAL BANKROLL: $550
                    this.players.push({
                        ...data,
                        chips: 550,
                        currentBet: 0, // Bet in the current street
                        status: 'ACTIVE',
                        totalBetThisHand: 0
                    });
                    console.log("✅ Player added successfully. Total players:", this.players.length);
                } else {
                    console.log("⚠️ Player already exists, skipping");
                }
            }

            handlePlayerAction(playerId, action, amount = 0) {
                const p = this.players.find(p => p.id === playerId);
                if (!p) return;

                const maxBet = Math.max(...this.players.map(pl => pl.currentBet), 0);
                const diff = maxBet - p.currentBet;

                console.log(`🏠 HOST: Action '${action}' from ${p.name}. MaxBet: ${maxBet}, Player's Bet: ${p.currentBet}, Diff: ${diff}`);

                if (action === 'FOLD') {
                    p.status = 'FOLDED';
                    // CHECK FOR EARLY WIN (Only 1 active player left)
                    const activePlayers = this.players.filter(pl => pl.status !== 'FOLDED');
                    if (activePlayers.length === 1) {
                        const winner = activePlayers[0];
                        this.players.forEach(pl => {
                            this.pot += pl.currentBet;
                            pl.currentBet = 0;
                        });
                        winner.chips += this.pot;
                        Swal.fire({
                            title: `¡${winner.name} GANA!`,
                            text: `Todos los demás se retiraron. Se lleva $${this.pot}.`,
                            icon: 'success',
                            background: '#1a1a24',
                            color: '#fff',
                            timer: 3000,
                            showConfirmButton: false
                        });
                        this.pot = 0;
                        this.resetRound();
                        return;
                    }
                }
                else if (action === 'CHECK') {
                    // Do nothing, just broadcast state so turn logically passes (if we had turn sequence)
                }
                else if (action === 'BET') {
                    const val = parseInt(amount);
                    if (p.chips >= val) {
                        p.chips -= val;
                        p.currentBet += val;
                        p.totalBetThisHand += val;
                    }
                }
                else if (action === 'CALL') {
                    if (p.chips >= diff) {
                        p.chips -= diff;
                        p.currentBet += diff;
                        p.totalBetThisHand += diff;
                    } else {
                        // All-in if can't match? For now, just take what they have
                        const all = p.chips;
                        p.chips = 0;
                        p.currentBet += all;
                        p.totalBetThisHand += all;
                        p.status = 'ALL-IN';
                    }
                }
                else if (action === 'RAISE') {
                    // Raise is CALL + extra
                    const extra = parseInt(amount);
                    const totalToCharge = diff + extra;
                    if (p.chips >= totalToCharge) {
                        p.chips -= totalToCharge;
                        p.currentBet += totalToCharge;
                        p.totalBetThisHand += totalToCharge;
                    }
                }

                this.broadcastState();
            }

            // --- HOST PHASE CONTROL ---
            nextPhase() {
                // 1. Enforce Betting Equality: Fold players who didn't match the highest bet
                // (Protection: Players with 0 chips are considered ALL-IN and are not forced to fold)
                const maxBet = Math.max(...this.players.map(p => p.currentBet), 0);

                this.players.forEach(p => {
                    if (p.status === 'ACTIVE' && p.currentBet < maxBet && p.chips > 0) {
                        p.status = 'FOLDED';
                    }
                });

                // 2. Collect all bets into Pot
                this.players.forEach(p => {
                    this.pot += p.currentBet;
                    p.currentBet = 0;
                });

                // 3. CHECK FOR EARLY WIN (If only 1 player remains active)
                const activePlayers = this.players.filter(pl => pl.status !== 'FOLDED');
                if (activePlayers.length === 1) {
                    const winner = activePlayers[0];
                    winner.chips += this.pot;

                    // Notify
                    Swal.fire({
                        title: `¡${winner.name} GANA!`,
                        text: `Todos los demás se retiraron o no igualaron la apuesta. Se lleva $${this.pot}.`,
                        icon: 'success',
                        background: '#1a1a24',
                        color: '#fff',
                        timer: 4000,
                        showConfirmButton: false
                    });

                    this.pot = 0;
                    this.resetRound(); // Auto-reset
                    return;
                }

                // 4. Advance Phase
                if (this.phaseIndex < this.PHASES.length - 1) {
                    this.phaseIndex++;
                }

                this.broadcastState();
            }

            resetRound() {
                this.phaseIndex = 0;
                this.pot = 0;
                this.players.forEach(p => {
                    p.currentBet = 0;
                    p.totalBetThisHand = 0;
                    p.status = p.chips > 0 ? 'ACTIVE' : 'BUSTED';
                });
                this.broadcastState();
            }

            resetGame() {
                // Reset EVERYTHING to initial session state
                this.phaseIndex = 0;
                this.pot = 0;
                this.players.forEach(p => {
                    p.chips = 550; // Restore starting bankroll
                    p.currentBet = 0;
                    p.totalBetThisHand = 0;
                    p.status = 'ACTIVE';
                });
                this.broadcastState();

                Swal.fire({
                    title: '¡PARTIDA REINICIADA!',
                    text: 'Todos los jugadores vuelven a tener $550.',
                    icon: 'success',
                    background: '#1a1a24',
                    color: '#fff',
                    timer: 2000,
                    showConfirmButton: false
                });
            }

            // Host manually awards pot
            // Host manually awards pot (Single or Split)
            distributePot(winnerIds) {
                if (!winnerIds || winnerIds.length === 0) return;

                // Tell everyone to animate
                this.net.send('WIN_ANIM', {});
                // Animate locally
                this.ui.triggerWinAnimation();

                // Small delay to let the animation play before resetting
                setTimeout(() => {
                    const count = winnerIds.length;
                    const share = Math.floor(this.pot / count);
                    const remainder = this.pot % count;

                    // BROADCAST CELEBRATION BEFORE UPDATING STATE
                    // This allows clients to know who won and how much, 
                    // and start the animation from their OLD balance.
                    const celebrationData = winnerIds.map((id, index) => ({
                        id: id,
                        amount: (index === 0) ? (share + remainder) : share
                    }));

                    this.net.send('WINNER_CELEBRATION', { winners: celebrationData });
                    this.ui.showWinnerCelebration(celebrationData);

                    // Distribute shares in state
                    celebrationData.forEach(win => {
                        const p = this.players.find(pl => pl.id === win.id);
                        if (p) {
                            p.chips += win.amount;
                        }
                    });

                    // Reset pot VISUALLY (logic handled in next resetRound usually, but let's clear it now to show it's done)
                    this.pot = 0;

                    // AUTO-RESET: Start new round after distributing prizes
                    this.resetRound();
                    // resetRound already calls broadcastState, no need to call it again
                }, 600);
            }

            // toggleWinner(id) is handled in UI local state, we just need the final call.

            clearPot() {
                this.pot = 0;
                this.broadcastState();
            }

            // --- STATE SYNC ---
            broadcastState() {
                console.log("Broadcasting State", this.players);
                const state = {
                    players: this.players,
                    pot: this.pot,
                    phaseIndex: this.phaseIndex,
                    phaseName: this.PHASES[this.phaseIndex]
                };

                // Local UI update for Host
                this.ui.render({ ...state, isHost: this.isHost }, this.myId);

                // Send to clients
                this.net.send('STATE_UPDATE', { state });
            }

            syncState(state) {
                this.players = state.players;
                this.pot = state.pot;
                this.phaseIndex = state.phaseIndex;
                this.ui.render({ ...state, isHost: this.isHost }, this.myId);
            }
            // --- CLIENT ACTIONS ---
            sendAction(action, amount = 0) {
                if (this.isHost) {
                    this.handlePlayerAction(this.myId, action, amount);
                } else {
                    this.net.send('ACTION', { id: this.myId, action, amount });
                }
            }

            // --- SYNC ---
            // (Replaces old broadcastState/syncState with nothing, as they are already defined above correctly)
        }


        /**
         * App Controller - Chip Tracker Edition
         */

        // --- GLOBAL APP API for Button Clicks (onclick in HTML) ---
        // Defined OUTSIDE DOMContentLoaded to ensure availability
        window.app = {
            transition: null, // Initialized later

            localBet: 0,

            // --- CHIP SELECTOR (Client) ---
            addChip: function (val) {
                this.localBet += val;
                this.updateUI();
            },
            clearPendingBet: function () {
                this.localBet = 0;
                this.updateUI();
            },

            // --- GAME ACTIONS (Client) ---
            doFold: function () {
                if (window.game) window.game.sendAction('FOLD');
            },
            doCheck: function () {
                if (window.game) {
                    window.game.sendAction('CHECK');
                    this.clearPendingBet();
                }
            },
            doBet: function () {
                if (window.game) {
                    const amount = this.localBet;
                    if (amount <= 0) return this.msg("Error", "Selecciona fichas para apostar.", "warning");
                    window.game.sendAction('BET', amount);
                    this.clearPendingBet();
                }
            },
            doCall: function () {
                if (window.game) {
                    window.game.sendAction('CALL');
                    this.clearPendingBet();
                }
            },
            doRaise: function () {
                if (window.game) {
                    const extra = this.localBet;
                    if (extra <= 0) return this.msg("Error", "Selecciona fichas extra para subir.", "warning");
                    window.game.sendAction('RAISE', extra);
                    this.clearPendingBet();
                }
            },

            // --- HOST ACTIONS ---
            hostNextPhase: function () {
                if (window.game) window.game.nextPhase();
            },
            hostResetRound: function () {
                Swal.fire({
                    title: '¿NUEVA PARTIDA?',
                    text: "Esto reseteará los saldos de TODOS los jugadores a $550 y limpiará la mesa.",
                    icon: 'warning',
                    showCancelButton: true,
                    background: '#1a1a24',
                    color: '#e0e0e0',
                    confirmButtonColor: '#ff4f4f',
                    cancelButtonColor: '#333',
                    confirmButtonText: 'REINICIAR TODO',
                    cancelButtonText: 'CANCELAR'
                }).then((result) => {
                    if (result.isConfirmed) {
                        window.game.resetGame();
                    }
                });
            },

            // Local state for selecting winners
            selectedWinners: [],

            toggleWinnerSelection: function (id) {
                const idx = this.selectedWinners.indexOf(id);
                if (idx === -1) this.selectedWinners.push(id);
                else this.selectedWinners.splice(idx, 1);

                // Re-render UI to show selection (we invoke global render or just update class?)
                // Full render is safest to keep sync, but might flicker. 
                // Let's just update the specific checkbox visual if possible, or re-render.
                // Actually relying on UIController to render "checked" state based on window.app.selectedWinners is better.
                if (window.game) window.game.ui.render(window.game, window.game.myId);
            },

            hostDistributePot: function () {
                // Modal based selection
                const players = window.game.players;
                const potAmount = window.game.pot;

                // Generate enhanced checkbox HTML with better styling
                let html = `
                    <div style="margin-bottom:15px; padding:10px; background:rgba(79,255,134,0.1); border-radius:5px;">
                        <p style="color:var(--accent-amber); font-size:1.3rem; margin:0;">
                            💰 BOTE: <b>$${potAmount}</b>
                        </p>
                    </div>
                    <div style="text-align:left; max-height:300px; overflow-y:auto; padding:5px;">
                `;

                players.forEach(p => {
                    const isFolded = p.status === 'FOLDED';
                    const bgColor = isFolded ? 'rgba(255,255,255,0.03)' : 'rgba(79,255,134,0.1)';
                    const borderColor = isFolded ? '#333' : 'var(--accent-green)';
                    const opacity = isFolded ? '0.5' : '1';

                    html += `
                        <div style="margin:8px 0; padding:10px; background:${bgColor}; border:1px solid ${borderColor}; border-radius:5px; opacity:${opacity}; transition:all 0.2s;">
                            <label for="winner-${p.id}" style="display:flex; align-items:center; gap:10px; cursor:pointer; font-size:1.1rem;">
                                <input type="checkbox" id="winner-${p.id}" value="${p.id}" ${!isFolded ? 'checked' : ''} 
                                    style="width:20px; height:20px; cursor:pointer; accent-color:var(--accent-green);">
                                <span style="flex:1;">
                                    <b>${p.name}</b>
                                    <span style="color:var(--accent-amber); margin-left:10px;">$${p.chips}</span>
                                </span>
                            </label>
                        </div>
                    `;
                });
                html += '</div>';

                Swal.fire({
                    title: '🏆 Seleccionar Ganadores',
                    html: html,
                    icon: 'question',
                    showCancelButton: true,
                    background: '#1a1a24',
                    color: '#e0e0e0',
                    confirmButtonColor: '#4fff86',
                    cancelButtonColor: '#ff4f4f',
                    confirmButtonText: '<span style="color:#000; font-weight:bold;">DISTRIBUIR BOTE</span>',
                    cancelButtonText: 'CANCELAR',
                    customClass: {
                        confirmButton: 'swal2-confirm-custom',
                        popup: 'swal2-popup-custom'
                    },
                    width: '500px',
                    preConfirm: () => {
                        const selected = [];
                        players.forEach(p => {
                            const cb = document.getElementById(`winner-${p.id}`);
                            if (cb && cb.checked) selected.push(p.id);
                        });
                        if (selected.length === 0) {
                            Swal.showValidationMessage('⚠️ Selecciona al menos un jugador');

                        }
                        return selected;
                    }
                }).then((result) => {
                    if (result.isConfirmed) {
                        window.game.distributePot(result.value);
                    }
                });
            },

            // --- GLOBAL HELPERS FOR SWEETALERT ---
            msg: function (title, text, icon = 'success') {
                Swal.fire({
                    title: title,
                    text: text,
                    icon: icon,
                    background: '#1a1a24',
                    color: '#e0e0e0',
                    confirmButtonColor: '#4ff0ff',
                    confirmButtonText: 'OK'
                });
            },

            updateUI: function () {
                const pendEl = document.getElementById('my-pending-bet');
                if (pendEl && window.game) {
                    window.game.ui.animateCounter(pendEl, this.localBet, "$");
                }

                // Check for Bankruptcy ($0 chips)
                if (window.game) {
                    const me = window.game.players.find(p => p.id === window.game.myId);
                    if (me && me.chips === 0) {
                        this.disableControls(true);
                    } else {
                        this.disableControls(false);
                    }
                }
            },

            disableControls: function (disable) {
                const btns = document.querySelectorAll('.chip-btn, .control-btn');
                const actionDiv = document.querySelector('.action-bar');

                btns.forEach(b => {
                    b.disabled = disable;
                    b.style.opacity = disable ? '0.3' : '1';
                    b.style.pointerEvents = disable ? 'none' : 'auto';
                });

                if (actionDiv) {
                    actionDiv.style.opacity = disable ? '0.5' : '1';
                }
            },

            // Helper to check if a player is bankrupt
            checkBankruptcy: function (player) {
                return player && player.chips === 0;
            },

            // --- QR CODE LOGIC ---
            qrScanner: null,
            scanTargetId: null,

            showQR: function (sourceId) {
                const text = document.getElementById(sourceId).value;
                if (!text) return this.msg("Error", "No hay código para mostrar.", "error");

                // Show Modal
                document.getElementById('modal-qr-show').style.display = 'flex';
                document.getElementById('qr-code-container').innerHTML = ""; // Clear previous

                try {
                    new QRCode(document.getElementById("qr-code-container"), {
                        text: text,
                        width: 256,
                        height: 256,
                        correctLevel: QRCode.CorrectLevel.L
                    });
                } catch (e) {
                    console.error(e);
                    this.msg("Error", "El código es demasiado largo para un QR estándar. Intenta copiar/pegar.", "error");
                }
            },

            // --- QR SCANNER LOGIC ---
            startQRScanner: function (targetFieldId) {
                this.scanTargetId = targetFieldId;
                const modal = document.getElementById('modal-qr-scanner');
                const statusEl = document.getElementById('qr-scan-status');

                modal.style.display = 'flex';
                statusEl.textContent = 'Iniciando cámara...';

                // Initialize scanner if not already created
                if (!this.qrScanner) {
                    this.qrScanner = new Html5Qrcode("qr-reader");
                }

                const config = {
                    fps: 10,
                    qrbox: { width: 250, height: 250 },
                    aspectRatio: 1.0
                };

                this.qrScanner.start(
                    { facingMode: "environment" }, // Use back camera on mobile
                    config,
                    (decodedText) => {
                        // Success! Scanned a QR code
                        console.log("📷 QR Scanned:", decodedText);
                        statusEl.textContent = '✅ ¡Código escaneado!';

                        // Auto-paste into target field
                        document.getElementById(this.scanTargetId).value = decodedText;

                        // Stop scanner and close modal
                        this.stopQRScanner();

                        this.msg("¡Éxito!", "Código QR escaneado y pegado automáticamente.", "success");
                    },
                    (errorMessage) => {
                        // Scanning in progress, no QR found yet - this is normal
                        // Don't show anything, just keep scanning
                    }
                ).catch((err) => {
                    // Camera access denied or error
                    console.error("QR Scanner error:", err);
                    statusEl.textContent = '❌ Error al acceder a la cámara';
                    this.msg("Error de Cámara",
                        "No se pudo acceder a la cámara. Verifica los permisos del navegador.",
                        "error");
                    modal.style.display = 'none';
                });
            },

            stopQRScanner: function () {
                if (this.qrScanner && this.qrScanner.isScanning) {
                    this.qrScanner.stop().then(() => {
                        console.log("📷 Scanner stopped");
                        document.getElementById('modal-qr-scanner').style.display = 'none';
                        document.getElementById('qr-scan-status').textContent = '';
                    }).catch((err) => {
                        console.error("Error stopping scanner:", err);
                        document.getElementById('modal-qr-scanner').style.display = 'none';
                    });
                } else {
                    document.getElementById('modal-qr-scanner').style.display = 'none';
                }
            },

            exitGame: function () {
                if (window.game && window.game.isHost) {
                    window.game.broadcastHostExit();
                }
                if (this.transition) {
                    this.transition(() => {
                        window.location.reload();
                    });
                } else {
                    window.location.reload();
                }
            }
        };

        document.addEventListener('DOMContentLoaded', () => {
            const net = new NetworkManager();
            const ui = new UIController();
            const game = new GameState(net, ui);
            const transition = new PixelTransition(12); // Premium 12x12 grid

            // Expose game globally so window.app can use it
            window.game = game;
            window.app.transition = (cb) => transition.play(cb);

            // --- DOM REFERENCES ---
            const d = {
                lobby: document.getElementById('view-lobby'),
                game: document.getElementById('view-game'),
                name: document.getElementById('player-name-input'),
                hostTab: document.querySelector('button[data-tab="host"]'),
                joinTab: document.querySelector('button[data-tab="join"]'),
                hostPanel: document.getElementById('panel-host'),
                joinPanel: document.getElementById('panel-join'),

                btnInitHost: document.getElementById('btn-init-host'), // NEW
                hostOffer: document.getElementById('host-offer'),
                hostAnswer: document.getElementById('host-answer'),
                btnCopyOffer: document.getElementById('btn-copy-offer'),
                btnConnectHost: document.getElementById('btn-connect-host'),

                btnShowInvite: document.getElementById('btn-show-invite'),
                inviteOverlay: document.getElementById('invite-overlay'),
                btnIngameGen: document.getElementById('btn-ingame-gen'),
                ingameOffer: document.getElementById('ingame-offer'),
                btnIngameCopy: document.getElementById('btn-ingame-copy'),
                ingameAnswer: document.getElementById('ingame-answer'),
                btnIngameConnect: document.getElementById('btn-ingame-connect'),
                btnCloseInvite: document.getElementById('btn-close-invite'),

                clientOffer: document.getElementById('client-offer'),
                clientAnswer: document.getElementById('client-answer'),
                btnGenAnswer: document.getElementById('btn-generate-answer'),
                btnCopyAnswer: document.getElementById('btn-copy-answer'),

                betDisplay: document.getElementById('my-pending-bet') // UPDATED ID
            };

            // ... (Global API) ...
            // DO NOT REMOVE window.app

            function updateLocalBetUI() {
                d.betDisplay.textContent = localBetAccumulator;
            }

            // --- LOBBY EVENTS ---
            d.hostTab.addEventListener('click', () => tab('host'));
            d.joinTab.addEventListener('click', () => tab('join'));

            function tab(t) {
                document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                if (t === 'host') {
                    d.hostPanel.classList.add('active');
                    d.hostTab.classList.add('active');
                    // initHost(); // REMOVED auto-call
                } else {
                    d.joinPanel.classList.add('active');
                    d.joinTab.classList.add('active');
                }
            }

            // AUTO-SELECT TEXTAREAS
            document.querySelectorAll('textarea').forEach(ta => {
                ta.addEventListener('focus', () => ta.select());
            });

            // --- LOBBY LOGIC WRAPPERS ---
            function showOverlay(title, msg) { ui.showOverlay(title, msg); }
            function hideOverlay() { ui.hideOverlay(); }

            // NEW: Manual Trigger Lobby
            d.btnInitHost.addEventListener('click', async () => {
                showOverlay("GENERANDO...", "Espera un momento, estamos creando el código de invitación...");
                d.hostOffer.value = "Generando código... Por favor espera...";
                await net.createHost((offer) => {
                    d.hostOffer.value = offer;
                    hideOverlay();
                    window.app.msg("¡Listo!", "Copia el código y envíaselo a tu amigo.", "success");
                });
            });

            d.btnCopyOffer.addEventListener('click', () => {
                navigator.clipboard.writeText(d.hostOffer.value);
                window.app.msg("¡Copiado!", "Código de invitación en portapapeles", "success");
            });

            d.btnConnectHost.addEventListener('click', () => {
                const answer = d.hostAnswer.value;
                if (!answer) return window.app.msg("Falta Respuesta", "Pega la respuesta del jugador invitado", "error");

                showOverlay("CONECTANDO...", "Estableciendo conexión P2P con el jugador...");

                // Start Game State NOW
                const name = d.name.value || "HOST";
                game.initHost(name);

                net.finalizeHostConnection(answer);

                // Hide overlay after a few seconds or when connection opens (handled in onConnectionOpen)
                // Failsafe error message with Wi-Fi hint
                const overlay = document.getElementById('connecting-overlay');
                setTimeout(() => {
                    if (overlay && overlay.style.display === 'flex') {
                        hideOverlay();
                        window.app.msg("Error de Conexión", "No se pudo establecer el túnel. Asegúrate de que tanto el Host como los jugadores estáis en la misma red Wi-Fi.", "error");
                    }
                }, 10000);
            });

            // Removed net.onConnectionOpen overwrite to allow GameState to handle it


            // --- INVITE OVERLAY EVENTS ---
            if (d.btnShowInvite && d.inviteOverlay) {
                d.btnShowInvite.addEventListener('click', () => {
                    d.inviteOverlay.style.display = 'flex';
                });
                d.btnCloseInvite.addEventListener('click', () => {
                    d.inviteOverlay.style.display = 'none';
                });
            }

            if (!d.btnIngameGen) console.error("CRITICAL: btn-ingame-gen not found in DOM!");
            else {
                d.btnIngameGen.addEventListener('click', async () => {
                    console.log("CLICK: In-Game Gen");
                    // alert("Generando código..."); // Debug feedback
                    d.ingameOffer.value = "Generando... Espera...";

                    try {
                        await net.createHost((offer) => {
                            console.log("Offer Generated:", offer);
                            d.ingameOffer.value = offer;
                        });
                    } catch (e) {
                        console.error("GEN ERROR:", e);
                        d.ingameOffer.value = "Error: " + e.toString();
                    }
                });
            }

            if (d.btnIngameCopy) {
                d.btnIngameCopy.addEventListener('click', () => {
                    navigator.clipboard.writeText(d.ingameOffer.value);
                    window.app.msg("¡Copiado!", "", "success");
                });
            }

            if (d.btnIngameConnect) {
                d.btnIngameConnect.addEventListener('click', async () => {
                    console.log("CLICK: In-Game Connect");
                    const ans = d.ingameAnswer.value;
                    if (ans) {
                        try {
                            await net.finalizeHostConnection(ans);
                            window.app.msg("¡Conectado!", "Jugador añadido con éxito", "success");
                            d.inviteOverlay.style.display = 'none';
                            d.ingameOffer.value = '';
                            d.ingameAnswer.value = '';
                        } catch (e) {
                            window.app.msg("Error", "Fallo al conectar: " + e.message, "error");
                        }
                    } else {
                        window.app.msg("Falta Respuesta", "Pega la respuesta del jugador.", "warning");
                    }
                });
            }

            d.btnGenAnswer.addEventListener('click', async () => {
                const name = d.name.value || "PLAYER";
                const offer = d.clientOffer.value;
                if (!offer) return window.app.msg("Falta Invitación", "Pega el código que te envió el Host.", "warning");

                showOverlay("GENERANDO...", "Creando tu código de respuesta...");
                game.initClient(name);
                d.clientAnswer.value = "Generando respuesta...";
                await net.joinGame(offer, (ans) => {
                    d.clientAnswer.value = ans;
                    hideOverlay();
                    window.app.msg("¡Respuesta Lista!", "Copia tu respuesta y envíasela al Host.", "success");
                });
            });
            d.btnCopyAnswer.addEventListener('click', () => {
                navigator.clipboard.writeText(d.clientAnswer.value);
                window.app.msg("¡Copiado!", "Envía esto al Host para que termine la conexión.", "success");
            });
        });

        /**
         * UI Controller
         */
        class UIController {
            constructor() {
                this.list = document.getElementById('players-list');
                this.status = document.getElementById('connection-status');
                this.btnInvite = document.getElementById('btn-show-invite');
                this.btnResetAll = document.getElementById('btn-reset-all');
            }

            showGame() {
                document.getElementById('view-lobby').classList.remove('active');
                document.getElementById('view-game').classList.remove('hidden');
                document.getElementById('view-game').classList.add('active');
                document.getElementById('btn-exit-game').style.display = 'block';
            }

            showOverlay(title, msg) {
                const overlay = document.getElementById('connecting-overlay');
                document.getElementById('overlay-title').textContent = title;
                document.getElementById('overlay-msg').textContent = msg;
                overlay.style.display = 'flex';
            }

            hideOverlay() {
                const overlay = document.getElementById('connecting-overlay');
                if (overlay) overlay.style.display = 'none';
            }

            triggerWinAnimation() {
                const cards = document.querySelectorAll('.card-slot.active');
                cards.forEach(card => card.classList.add('card-vibrate'));
                setTimeout(() => {
                    cards.forEach(card => card.classList.remove('card-vibrate'));
                }, 600);
            }

            updateLobbyStatus(msg) {
                this.status.textContent = msg;
                if (msg === 'CONECTADO') this.status.classList.add('connected');
            }

            setHostMode(isHost) {
                const b = document.getElementById('btn-show-invite');
                const r = document.getElementById('host-round-controls');
                if (isHost) {
                    if (b) b.style.display = 'inline-block';
                    if (r) r.style.display = 'flex';
                } else {
                    if (b) b.style.display = 'none';
                    if (r) r.style.display = 'none';
                }
            }

            animateCounter(element, targetValue, prefix = "", suffix = "", isMe = false) {
                if (!element) return;

                // Track current value on the element itself to handle interruptions
                const currentStr = element.getAttribute('data-v-val') || element.textContent.replace(prefix, "").replace(suffix, "").replace(/[^\d]/g, "");
                let current = parseInt(currentStr) || 0;
                const target = parseInt(targetValue) || 0;

                if (current === target) {
                    element.setAttribute('data-v-val', target);
                    return;
                }

                // If there's already an active animation for this element, clear its interval
                if (element._animId) {
                    cancelAnimationFrame(element._animId);
                }

                // Calculate step size based on difference (faster for larger differences)
                const diff = Math.abs(target - current);
                const stepSize = Math.max(1, Math.ceil(diff / 15)); // Complete animation in ~15 frames

                let lastTime = performance.now();
                const step = (currentTime) => {
                    const elapsed = currentTime - lastTime;

                    // Update every frame (60fps) instead of waiting
                    if (elapsed > 0) {
                        lastTime = currentTime;

                        if (current < target) {
                            current = Math.min(current + stepSize, target);
                        } else if (current > target) {
                            current = Math.max(current - stepSize, target);
                        }

                        element.textContent = `${prefix}${current}${suffix}`;
                        element.setAttribute('data-v-val', current);

                        // Reactive styling if balance
                        if (element.classList.contains('hand-balance') || element.id === 'my-chips-disp') {
                            element.style.cssText = this.getBalanceStyle(current, isMe);
                        }
                    }

                    if (current !== target) {
                        element._animId = requestAnimationFrame(step);
                    } else {
                        delete element._animId;
                    }
                };

                element._animId = requestAnimationFrame(step);
            }

            getBalanceStyle(amount, isMe = false) {
                let color = 'var(--accent-green)';
                let glow = 'none';
                let baseSize = isMe ? 1.8 : 1.0;

                if (amount < 200) {
                    color = '#ff4f4f'; // Red
                } else if (amount < 550) {
                    color = '#ffb84f'; // Amber
                } else if (amount >= 1000) {
                    color = '#4ff0ff'; // Cyan
                    glow = '0 0 10px rgba(79, 240, 255, 0.6)';
                }

                // Growth logic: Increase size up to +0.8rem for high amounts
                const growth = Math.min(0.8, Math.max(0, (amount - 550) / 1000));
                const finalSize = (baseSize + growth).toFixed(2);

                return `color: ${color}; font-size: ${finalSize}rem; text-shadow: ${glow}; font-weight: bold;`;
            }

            showWinnerCelebration(winners) {
                if (!winners || winners.length === 0) return;

                winners.forEach(win => {
                    const isMe = (win.id === window.game.net.id);
                    let balanceEl = null;
                    let containerEl = null;

                    if (isMe) {
                        balanceEl = document.getElementById('my-chips-disp');
                        containerEl = document.getElementById('my-stats-box');
                    } else {
                        // Find by data-player-id
                        balanceEl = document.querySelector(`.hand-balance[data-player-id="${win.id}"]`);
                        if (balanceEl) {
                            containerEl = balanceEl.closest('.hand-container');
                        }
                    }

                    if (containerEl && balanceEl) {
                        // 1. ADD WINNER ALERT
                        const alert = document.createElement('div');
                        alert.className = 'winner-alert';
                        alert.textContent = `¡GANADOR! +$${win.amount}`;
                        containerEl.appendChild(alert);
                        containerEl.classList.add('winner-pulse');

                        // 2. COUNTER ANIMATION (Pure JS 1-by-1)
                        const currentVal = parseInt(balanceEl.getAttribute('data-v-val') || balanceEl.textContent.replace(/[^\d]/g, '')) || 0;
                        const targetVal = currentVal + win.amount;
                        this.animateCounter(balanceEl, targetVal, "$", "", isMe);

                        setTimeout(() => {
                            if (alert.parentNode) alert.parentNode.removeChild(alert);
                            containerEl.classList.remove('winner-pulse');
                        }, 4000);
                    }
                });
            }

            render(state, myId) {
                try {
                    // Show Invite/Reset Button if Host
                    if (state.isHost) {
                        if (this.btnInvite) this.btnInvite.style.display = 'inline-block';
                        const roundCtrl = document.getElementById('host-round-controls');
                        if (roundCtrl) roundCtrl.style.display = 'flex';

                        // TOGGLE BUTTONS: Logic Enforced based on Phase Name/Index
                        const distBtn = document.getElementById('btn-distribute-pot');
                        const nextBtn = document.getElementById('btn-next-phase');

                        // Robust check for Resolution phase (Index 4 or Name 'RESOLUCION')
                        const isResolution = (state.phaseIndex >= 4) || (state.phaseName === 'RESOLUCION');

                        if (isResolution) {
                            // Phase Resolution: Show Distribute, Hide Next
                            if (distBtn) distBtn.style.display = 'inline-block';
                            if (nextBtn) nextBtn.style.display = 'none';
                        } else {
                            // Phase Preflop/Flop/Turn/River: Show Next, Hide Distribute
                            if (distBtn) distBtn.style.display = 'none';
                            if (nextBtn) nextBtn.style.display = 'inline-block';
                        }
                    }

                    this.list.innerHTML = '';

                    // Note: We don't want to redraw the WHOLE UI if an animation is playing on a balance,
                    // but render() is called on every state change. 
                    // To prevent flickering or resetting values mid-animation, 
                    // we could check if an animation is active.
                    // For now, let's just redraw but keep in mind the showWinnerCelebration 
                    // adds elements that will be cleared by this innerHTML = ''.
                    // We'll rely on the fact that distributePot triggers the animation 
                    // and then resetRound (which calls render) has a slight delay or happens after.

                    // Update Pot
                    const potEl = document.getElementById('pot-display');
                    const potChipsEl = document.getElementById('pot-chips');
                    if (potEl) {
                        this.animateCounter(potEl, state.pot, "BOTE: $");
                    }
                    if (potChipsEl) {
                        const potChipData = this.getChipData(state.pot);
                        potChipsEl.innerHTML = potChipData.html;
                    }

                    // Update Phase
                    const phaseEl = document.getElementById('phase-display');
                    if (phaseEl) phaseEl.innerText = state.phaseName || 'ESPERANDO';

                    // Community Cards Update
                    for (let i = 1; i <= 5; i++) {
                        const cardEl = document.getElementById('card-' + i);
                        if (cardEl) {
                            let show = false;
                            if (state.phaseIndex >= 1 && i <= 3) show = true; // Flop
                            if (state.phaseIndex >= 2 && i <= 4) show = true; // Turn
                            if (state.phaseIndex >= 3 && i <= 5) show = true; // River/Showdown

                            if (show) {
                                cardEl.classList.add('active');
                                cardEl.textContent = '🂠';
                            } else {
                                cardEl.classList.remove('active');
                                cardEl.textContent = '?';
                            }
                        }
                    }

                    console.log(`Render: Phase=${state.phaseIndex} MyID=${myId}`);

                    state.players.forEach(p => {
                        const isMe = (p.id === myId);

                        if (isMe) {
                            // UPDATE MY FOOTER STATS
                            const myNameEl = document.getElementById('my-name-disp');
                            const myChipsEl = document.getElementById('my-chips-disp');
                            if (myNameEl) myNameEl.textContent = p.name;
                            if (myChipsEl) {
                                this.animateCounter(myChipsEl, p.chips, "$", "", true);
                            }

                            // --- BETTING BUTTONS VISIBILITY (Strict Texas Hold'em Flow) ---
                            const btns = {
                                pasar: document.getElementById('btn-pasar'),
                                apostar: document.getElementById('btn-apostar'),
                                igualar: document.getElementById('btn-igualar'),
                                subir: document.getElementById('btn-subir'),
                                fold: document.getElementById('btn-retirarse'),
                                clear: document.getElementById('btn-limpiar')
                            };

                            // Helper to hide all
                            Object.values(btns).forEach(b => { if (b) b.style.display = 'none'; });

                            const isResolution = state.phaseIndex >= 4;
                            const maxBet = Math.max(...state.players.map(pl => pl.currentBet), 0);
                            const isActive = p.status === 'ACTIVE';

                            if (!isResolution && isActive) {
                                if (btns.fold) btns.fold.style.display = 'block';
                                if (btns.clear) btns.clear.style.display = 'block';

                                if (state.phaseIndex === 0) {
                                    // PREFLOP: Always bet exist (blinds, but here simplified as 0 or higher)
                                    // Show Call/Raise
                                    if (btns.igualar) btns.igualar.style.display = 'block';
                                    if (btns.subir) btns.subir.style.display = 'block';
                                } else {
                                    // POST-FLOP
                                    if (maxBet === 0) {
                                        if (btns.pasar) btns.pasar.style.display = 'block';
                                        if (btns.apostar) btns.apostar.style.display = 'block';
                                    } else {
                                        if (btns.igualar) btns.igualar.style.display = 'block';
                                        if (btns.subir) btns.subir.style.display = 'block';
                                    }
                                }
                            }

                            // Check bankruptcy for self immediately on render
                            if (p.chips === 0) window.app.disableControls(true);
                            else window.app.disableControls(false);

                            return; // Don't add me to the grid
                        }

                        // RENDER OTHERS IN GRID (Persistent Update Pattern)
                        let container = this.list.querySelector(`.hand-container[data-p-id="${p.id}"]`);
                        const isNewPlayer = !container;

                        if (!container) {
                            container = document.createElement('div');
                            container.className = 'hand-container';
                            container.setAttribute('data-p-id', p.id);
                            container.innerHTML = `
                                <div class="hand-header">
                                    <div class="hand-name"></div>
                                    <div class="hand-balance" data-player-id="${p.id}">$0</div>
                                </div>
                                <div class="hand-status-bar">
                                    <div class="status-badge"></div>
                                </div>
                                <div class="hand-footer">
                                    <div class="bet-label">Fichas en Mesa</div>
                                    <div class="chips-row" style="height:auto; min-height:25px; transform:scale(0.9);"></div>
                                </div>
                            `;
                            this.list.appendChild(container);
                        }

                        const isHostPlayer = (state.players.indexOf(p) === 0);
                        let statusClass = 'check';
                        let statusTxt = 'PASO';
                        let statusAmount = 0;

                        if (p.status === 'FOLDED') {
                            statusClass = 'fold';
                            statusTxt = 'RETIRADO';
                            container.style.opacity = '0.6';
                        } else if (p.status === 'ALL-IN') {
                            statusClass = 'allin';
                            statusTxt = 'ALL-IN';
                            container.style.opacity = '1';
                        } else if (p.currentBet > 0) {
                            container.style.opacity = '1';
                            const maxBet = Math.max(...state.players.map(pl => pl.currentBet), 0);
                            statusAmount = p.currentBet;
                            if (p.currentBet === maxBet) {
                                const countAtMax = state.players.filter(pl => pl.currentBet === maxBet).length;
                                if (countAtMax > 1) {
                                    statusClass = 'call';
                                    statusTxt = `IGUALA: $`;
                                } else {
                                    statusClass = 'bet';
                                    statusTxt = `APUESTA: $`;
                                }
                            } else {
                                statusClass = 'raise';
                                statusTxt = `SUBE: $`;
                            }
                        } else {
                            container.style.opacity = '1';
                            statusClass = 'check';
                            statusTxt = 'PASO';
                        }

                        // Update child elements
                        const nameEl = container.querySelector('.hand-name');
                        const balEl = container.querySelector('.hand-balance');
                        const badgeEl = container.querySelector('.status-badge');
                        const chipsRow = container.querySelector('.chips-row');

                        if (nameEl) {
                            nameEl.innerHTML = `${p.name} ${isHostPlayer ? '<span style="color:var(--accent-amber); font-size:0.7rem; margin-left:4px;">[HOST]</span>' : ''}`;
                        }

                        // Animate balance counter
                        if (balEl) {
                            this.animateCounter(balEl, p.chips, "$", "", false);
                        }

                        // Update and animate status badge
                        if (badgeEl) {
                            badgeEl.className = `status-badge ${statusClass}`;
                            if (statusAmount > 0) {
                                this.animateCounter(badgeEl, statusAmount, statusTxt);
                            } else {
                                badgeEl.textContent = statusTxt;
                                badgeEl.removeAttribute('data-v-val');
                            }
                        }

                        // Update chip visualization
                        if (chipsRow) {
                            const chipData = this.getChipData(p.currentBet);
                            chipsRow.innerHTML = chipData.html;
                        }
                    });

                    // Remove disconnected players
                    const currentIds = state.players.map(p => p.id);
                    const domContainers = this.list.querySelectorAll('.hand-container[data-p-id]');
                    domContainers.forEach(c => {
                        const pId = c.getAttribute('data-p-id');
                        if (!currentIds.includes(pId)) {
                            this.list.removeChild(c);
                        }
                    });
                } catch (e) {
                    console.error("Render Error:", e);
                }
            }

            getChipData(totalAmount) {
                let rem = totalAmount;
                const blacks = Math.floor(rem / 100); rem %= 100;
                const greens = Math.floor(rem / 25); rem %= 25;
                const blues = Math.floor(rem / 10); rem %= 10;
                const reds = Math.floor(rem / 5); rem %= 5;
                const whites = rem;

                let html = '';

                // helper to generate stack
                const addChips = (count, color, val) => {
                    if (count <= 0) return '';
                    if (count <= 5) { // Show up to 5 individually
                        let str = '';
                        for (let i = 0; i < count; i++) str += `<div class="chip ${color}">$${val}</div>`;
                        return str;
                    } else {
                        // Stack visual: Show 1 chip with xN counter
                        return `
                            <div style="display:flex; align-items:center;">
                                <div class="chip ${color}">$${val}</div>
                                <span class="chip-stack-count">x${count}</span>
                            </div>
                         `;
                    }
                };

                html += addChips(blacks, 'black', 100);
                html += addChips(greens, 'green', 25);
                html += addChips(blues, 'blue', 10);
                html += addChips(reds, 'red', 5);
                html += addChips(whites, 'white', 1);

                return { html, total: totalAmount };
            }
        }

        /*
        # Análisis del Flujo de Código - Pixel Blackjack
        
        Este documento detalla la estructura y flujo de la aplicación unificada en `index.html`.
        
        ## Estructura General
        
        La aplicación sigue una arquitectura **MVC simplificada** (Model-View-Controller) orientada a eventos, contenida en clases JS:
        
        1.  **`NetworkManager` (Networking)**: Maneja las conexiones WebRTC (P2P).
            *   Actúa como capa de transporte.
            *   Soporta múltiples conexiones para el Host (Topología estrella: Host <-> Múltiples Clientes).
        2.  **`GameState` (Model/Logic)**: Mantiene la "verdad" del juego.
            *   Gestiona la lista de jugadores, fichas, apuestas y fase del juego.
            *   El Host es la autoridad; los clientes solo replican el estado.
        3.  **`UIController` (View)**: Manipula el DOM.
            *   Dibuja la mesa, fichas y controles según el estado.
        4.  **`window.app` (Controller/Bridge)**: Puente para eventos del DOM.
            *   Expone funciones llamadas por `onclick` en el HTML.
        
        ---
        
        ## Flujo de Datos Principal
        
        ### 1. Inicialización (`DOMContentLoaded`)
        *   Se instancian `NetworkManager`, `UIController` y `GameState`.
        *   Se asigna `window.game` para acceso global.
        *   Se configuran los "Event Listeners" de la Lobby (crear/unirse).
        
        ### 2. Conexión (WebRTC Handshake)
        El flujo de conexión es manual (Copiar/Pegar SDP):
        
        **Caso HOST:**
        1.  Usuario click "CREAR (HOST)" -> `net.createHost()`.
        2.  `NetworkManager` crea un `RTCPeerConnection` y un `DataChannel` ('gameData').
        3.  Genera **OFFER**. Usuario la copia y envía al amigo.
        4.  Usuario pega la **ANSWER** del amigo -> `net.finalizeHostConnection()`.
        5.  Conexión establecida: Se dispara `onConnectionOpen` -> `game.initHost()`.
        
        **Caso CLIENTE:**
        1.  Usuario pega **OFFER** -> `net.joinGame()`.
        2.  `NetworkManager` crea `RTCPeerConnection` (sin DataChannel propio, espera el del host).
        3.  Genera **ANSWER**. Usuario copia y envía al Host.
        4.  Conexión establecida: Se dispara `onConnectionOpen` -> Envia mensaje `JOIN` con su nombre.
        
        ### 3. Loop de Juego (Sincronización de Estado)
        
        El estado fluye mayormente en una dirección: **HOST -> CLIENTES**.
        
        *   **Acción del Cliente (ej. Apostar):**
            1.  Cliente llama `game.placeBet(50)`.
            2.  `game` detecta que no es Host -> envía mensaje `BET` por la red.
            3.  Host recibe `BET` -> `game.handleMessage()`.
            4.  Host valida y actualiza su `this.players`.
            5.  Host invoca `this.broadcastState()` -> Envía el estado completo a TODOS.
        
        *   **Actualización de UI:**
            1.  Clientes reciben `STATE_UPDATE`.
            2.  `game.syncState()` actualiza su copia local.
            3.  `ui.render()` redibuja toda la mesa basándose en el nuevo estado.
        
        ---
        
        ## Funciones Clave
        
        ### `NetworkManager`
        *   `createHost(cb)`: Inicia proceso de Host, crea DataChannel.
        *   `joinGame(offer, cb)`: Inicia proceso Cliente, responde a oferta.
        *   `send(type, payload)`: Envía JSON a los pares conectados.
        
        ### `GameState`
        *   `broadcastState()`: **CRÍTICO**. Serializa `players`, `phase`, etc., y lo envía a la red. Luego llama a render.
        *   `resolvePlayer(id, result)`: Lógica de fin de ronda. Calcula pagos (WIN x2, BJ x2.5, etc.) y actualiza fichas. Solo el Host puede ejecutarlo.
        *   `handleMessage(msg)`: Router de mensajes.
            *   Si es Host: Procesa `BET`, `JOIN`.
            *   Si es Cliente: Procesa `STATE_UPDATE`.
        
        ### `UIController`
        *   `render(state)`: Función monolítica que borra y reconstruye la lista de jugadores.
        *   `getChipData(amount)`: Algoritmo "Codicioso" (Greedy) para convertir un valor numérico (ej. 156) en fichas físicas (1x100, 2x25, 1x5, 1x1).
        
        ### `window.app`
        *   `submitBet()`: Toma la apuesta local acumulada y la envía al `GameState`.
        *   `addChip(val)`: Suma a la apuesta local temporal (feedback visual inmediato antes de confirmar).
        
        ---
        */
    </script>
</body>

</html>